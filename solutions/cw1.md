# Контрольная работа №1
## Задача E
В задаче требуется найти кол-во пар соседних чисел, которые расположены по возрастанию. Заметьте, что длина последовательности может быть довольно большой, поэтому решать надо без использования массивов.

```cpp
#include <iostream>

using namespace std;

int main() {
    int ans = 0;
    int prev;
    cin >> prev;
    int cur = prev;
    while (cur) {
        prev = cur;
        cin >> cur;
        if (prev < cur) {
            ans++;
        }
    }
    cout << ans << endl;
    return 0;
}
```

## Задача F 
Для решения задачи необходимо написать **только** функцию. Она должна сдвигать все элементы массива вперед на 1 ячейку.

```cpp
void cycle_shift(int *a, int n) {
    int t = a[0];
    for (int i = 0; i < n-1; i++) {
        a[i] = a[i+1];
    }
    a[n-1] = t;
}
```

## Задача G
Так же, как и в задаче F, надо написать только функцию. Скалярное произведение - сумма произведений соответствующих элементов двух векторов. 

```cpp
int dot_product(int n, int *u, int *v) {
    int prod = 0;
    for (int i = 0; i < n; i++) {
        prod += u[i] * v[i];
    }
    return prod;
}
```

## Задача H
В задаче необходимо по заданным координатам мин восстановить игровое поле игры "Сапер". Заметьте, что координаты лежат на отрезках `[1, N]` и `[1, M]`. Подход к решению следующий: считываем очередную пару координат мины, соответствующую ячейку массива обозначаем `-1`, значения в ячейках вокруг текущей увеличиваем на 1 (только если в ячейке нет мины, т.е. значение `!= -1`). Также необходимо проверять, что мы не вышли за пределы поля.

```cpp
#include <iostream>

using namespace std;

int main() {
    int n, m, k;
    cin >> n >> m >> k;
    int **a = new int*[n];
    for (int i = 0; i < n; i++) {
        a[i] = new int[m]();
    }
    int dx[8] = {0, 1, 1, 1, 0, -1, -1, -1};
    int dy[8] = {1, 1, 0, -1, -1, -1, 0, 1};
    for (;k;k--) {
        int x, y;
        cin >> x >> y;
        x--;
        y--;
        a[x][y] = -1;
        for (int i = 0; i < 8; i++) {
            if (x + dx[i] >= 0 && x + dx[i] < n &&
                y + dy[i] >= 0 && y + dy[i] < m &&
                a[x + dx[i]][y + dy[i]] != -1) {
                    a[x + dx[i]][y + dy[i]]++;
                }

        }
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cout << a[i][j] << ' ';
        }
        cout << endl;
        delete[] a[i];
    }
    delete[] a;
    return 0;
}
```

## Задача I
Для того, чтобы развернуть массив, удобнее завести новый массив. Можно заметить, что после поворота на 90 градусов ячейка с координатами `(i, j)` переходит в `(j, n-i-1)`. Используя данную зависимость, получаем решениие.

```cpp
#include <iostream>

using namespace std;

int main() {
    int n;
    cin >> n;
    int **a = new int*[n];
    for (int i = 0; i < n; i++) {
        a[i] = new int[n];
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            int x;
            cin >> x;
            a[j][n-i-1] = x;
        }
    } 
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cout << a[i][j] << ' ';
        }
        cout << endl;
        delete[] a[i];
    }
    delete[] a;
    return 0;
}
```